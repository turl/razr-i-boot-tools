/*
 * read_data.c
 *
 * Copyright 2013 Pavel Moravec
 * Modified for ZTE GXI by Pavel Moravec, 2014 
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 *
 *
 */

#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <endian.h>

#include "mbrheader.h"
#include "bootheader.h"
#ifdef PC
#define ORIGIN "mmcblk0.img"
#else
#define ORIGIN "/dev/block/mmcblk0"
#endif

typedef enum {A_NONE=0, A_BOOT=1, A_REC=2, A_FAST=4, A_INFO=8, A_HELP = 0x10, A_ALL=0xf} e_args;

char * odir = ".";
char *origin=ORIGIN;
char second = 0;

e_args args = 0;

unsigned char header512[] = {
  0x24, 0x4f, 0x53, 0x24, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x38, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x00, 0x10, 0x10, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa
};


void usage(char *app) {
  MESSAGE("Usage: %s {-v | -b | -r | -f | -a } [-2] [-i <input>] [-o <out dir>]\n", app);
  MESSAGE("-v - print info about images from boot sector\n");
  MESSAGE("-b - retrive boot.img \n");
  MESSAGE("-f - retrive fastboot.img \n");
  MESSAGE("-r - retrieve recovery\n");
  MESSAGE("-a - retrieve all images\n\n");

  MESSAGE("-2 - use the second MBR record in case of divergent copies\n"); 
  MESSAGE("-i - input file (current: %s)\n", origin); 
  ERROR  ("-o - existing directory to store the output images (current: %s)\n", odir); 
}

e_args parse_arg(char *arg1, char *arg2) {
  e_args curr=0;
  if (arg1[0] == '-') {
	 int i;
     for(i=strlen(arg1)-1; i > 0; i--) {
       switch(arg1[i]) {
         case '2': 
		second = 1;
		break;
         case 'v': 
		curr |= A_INFO;
		break;
         case 'b': 
		curr |= A_BOOT;
		break;
         case 'f': 
		curr |= A_FAST;
		break;
         case 'r': 
		curr |= A_REC;
		break;
         case 'a': 
		curr |= A_ALL;
		break;
         case 'i': 
		if (arg2 == NULL) { curr |= A_HELP; break;}
                if (arg2[0] == '-' && arg2[1] == '\0') {
   			origin = "/dev/stdin";
			arg2[0]='\0';
		} else {
   			origin = arg2;
		}
		return curr;
         case 'o': 
		if (arg2 == NULL) { curr |= A_HELP; break;}
		odir = arg2;
		return curr;
	 default: 
		curr |= A_HELP;
		break;
       } 
     }
  }
  return curr;
}


void checkHeader(mainheader* mbr)
{
   if (memcmp(mbr->hdr,IMAGE_HDR, sizeof(mbr->hdr))) ERROR("ERROR: Invalid Image header - is it really ZTE GXI?\n");
}

void checkEntry(hdr_ent* e)
{
  if (le32toh(e->magic1) != MAGIC1 || le32toh(e->magic2) != MAGIC2 || le32toh(e->separator) != SEPARATOR) ERROR("Invalid boot record entry\n");
}

char * getImageType(uint32_t image_t) {
  switch(le32toh(image_t)) {
    case T_RECOVERY:
        return "recovery";
    case T_BOOT:
        return "boot";
    case T_FASTBOOT:
        return "fastboot";
    default:
        return "unknown";
  }
}

char is_enabled(uint32_t image_t) {
  switch(le32toh(image_t)) {
    case T_RECOVERY:
	return (args & A_REC);
    case T_BOOT:
	return (args & A_BOOT);
    case T_FASTBOOT:
	return (args & A_FAST);
    default:
        return 0;
  }
}


void printinfo(char * mbr, uint8_t offset) 
{
  printf("MBR info (offset 0x%x)\n", offset );
  int i=0;
  do {
    hdr_ent *e = (hdr_ent*) (mbr + sizeof(mainheader) + sizeof(hdr_ent) * i++);
    if (e->start_s == 0xffffffff || ((char*)e) - mbr > MBR_HDR_LEN) { break; }
    printf("Image %i (%8s), start %8u, length %8u\n", i, getImageType(e->image_type), le32toh(e->start_s), le32toh(e->sectors_t)); 
  } while (1);
}

char process_image(hdr_ent *e, FILE *finput)
{
  if (is_enabled(e->image_type)) {
    char * filename = calloc(strlen(odir)+BUFSIZ, 1);
    FILE * foutput;
	char buf[BUFSIZ];
	size_t start = le32toh(e->start_s) * 512;
    size_t missing = le32toh(e->sectors_t) * 512;
    struct bootheader * hdr;

    snprintf(filename, BUFSIZ, "%s/%s.img", odir, getImageType(e->image_type));
    foutput = fopen(filename, "wb");
    if (!foutput)
	ERROR("ERROR: failed to open output %s\n", filename);
    MESSAGE("Saving %s image in %s\n", getImageType(e->image_type), filename);
    hdr = (struct bootheader *)malloc(SECTOR);    
    memcpy(hdr, header512, SECTOR);
    hdr->sectors_t = e->sectors_t;
    hdr->image_type = e->image_type;
    hdr->xor56 = calc_sum(hdr);
    
    if (fwrite(hdr, SECTOR, 1, foutput) != 1) 
		ERROR("ERROR: failed to write output header\n");
   
    fflush(foutput);
	if (fseek(finput, start, SEEK_SET) == -1)
		ERROR("ERROR: failed to seek in input\n");
		
	while (missing > 0) {
		size_t size = fread(buf, 1, ((missing > BUFSIZ) ? BUFSIZ : missing), finput);
		if (size != 0) {
			fwrite(buf, 1, size, foutput);
			missing -= size;
		} else if (missing > 0){
			ERROR("ERROR: failed to read from input\n");
		}
	}

    free(filename);
    fclose(foutput);
	return 0;
  } else {
    MESSAGE("Skipping %s image\n", getImageType(e->image_type));
    return 1;
  }
}

void process_mbr(char * mbr, uint8_t offset, FILE *input) 
{
  int i=0;
  do {
    hdr_ent *e = (hdr_ent*) (mbr + offset + sizeof(mainheader) + sizeof(hdr_ent) * i++);
    if (e->start_s == 0xffffffff || ((char*)e) - mbr > MBR_HDR_LEN) { break; }
    process_image(e, input);
  } while (1);
}

//	foutput = fopen("tmp.bin", "w");

int main(int argc, char *argv[])
{
	FILE *forigin;

	char mbr[SECTOR];

	int i;
	for(i=1; i < argc ; i++) {
	  args |= parse_arg(argv[i], (argc-i > 1)?argv[i+1]:NULL);
	}


	if (argc ==  1 || (args & A_HELP)) { usage(argv[0]); }

	forigin = fopen(origin, "rb");


	if (!forigin)
		ERROR("ERROR: failed to open input %s\n", origin);


	if (fread(mbr, SECTOR, 1, forigin) != 1) ERROR("ERROR: Can't load MBR\n");

  	checkHeader((mainheader*) mbr);
	if (args & A_INFO) {
		printinfo(mbr, 0);
		putchar('\n');
		printinfo(mbr, MBR_HDR_LEN);
	}

	if (memcmp(mbr, mbr+MBR_HDR_LEN, MBR_HDR_LEN - 8)) 
		  MESSAGE("WARNING: divergent MBR image records, using the %s one\n", (second)?"second":"first");
	process_mbr(mbr, (second)?MBR_HDR_LEN:0, forigin);
	return 0;
}
